export_library
{
	std_io_directory :: struct;

	std_io_directory_entry :: struct
	{
		type: std_io_directory_entry_type;
		name: string;
	}

	std_io_directory_error :: enum u8
	{
		STD_IO_DIRECTORY_ERROR_NONE;
		STD_IO_DIRECTORY_ERROR_UNKNOWN;
	}

	std_io_directory_entry_type :: enum u8
	{
		STD_IO_DIRECTORY_ENTRY_TYPE_UNKNOWN;
		STD_IO_DIRECTORY_ENTRY_TYPE_FILE;
		STD_IO_DIRECTORY_ENTRY_TYPE_DIRECTORY;
		STD_IO_DIRECTORY_ENTRY_TYPE_SYMLINK;
	}

	std_io_directory_open  :: fn (directory: std_io_directory&, directory_path: string) -> std_io_directory_error;
	std_io_directory_close :: fn (directory: std_io_directory&);

	std_io_directory_for_each :: it (directory: std_io_directory&, declare directory_entry: std_io_directory_entry);
	// std_io_directory_for_each_recursive :: it (directory: std_io_directory&, declare directory_entry: std_io_directory_entry);
}

import
{
	"clib/string";
	"linux/dirent";
}

#if OS_LINUX
std_io_directory :: struct
{
	dir: linux_dir&;
}

std_io_directory_open :: fn (directory: std_io_directory&, directory_path: string) -> std_io_directory_error
{
	dir: linux_dir& = linux_opendir(directory_path.data as c_char&);

	if (dir == NULL)
	{
		// TODO: handle errors
		return STD_IO_DIRECTORY_ERROR_UNKNOWN;
	}

	directory.dir = dir;
	return STD_IO_DIRECTORY_ERROR_NONE;
}

std_io_directory_close :: fn (directory: std_io_directory&)
{
	linux_closedir(directory.dir) as void;
}

std_io_directory_for_each :: it (directory: std_io_directory&, declare directory_entry: std_io_directory_entry)
{
	while (true)
	{
		dirent: linux_dirent& = linux_readdir(directory.dir);

		// TODO: handle errors
		if (dirent == NULL)
		{
			break;
		}

		// TODO: convert linux dirent d_type to std_io_directory_entry_type
		directory_entry.type = STD_IO_DIRECTORY_ENTRY_TYPE_UNKNOWN;
		directory_entry.name = string { dirent.d_name as u8&, clib_strlen(dirent.d_name) };
		yield;
	}
}
#else
std_io_directory :: struct
{
	_: u8;
}

std_io_directory_open :: fn (directory: std_io_directory&, directory_path: string) -> std_io_directory_error
{
	return STD_IO_DIRECTORY_ERROR_UNKNOWN;
}

std_io_directory_close :: fn (directory: std_io_directory&)
{

}

std_io_directory_for_each :: it (directory: std_io_directory&, declare directory_entry: std_io_directory_entry)
{

}
#end
